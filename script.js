// Hardcoded tokens array (using a subset of your sample output)
const tokens = [
    {
      lexeme: "// Global variable declarations",
      // The DFA states will be generated by processing each character.
    },
    {
      lexeme: "Ginti",
    },
    {
      lexeme: "x",
    },
    {
      lexeme: "=",
    },
    {
      lexeme: "42",
    },
    {
      lexeme: ";",
    },
    {
      lexeme: "PointWalaNumber",
    },
    {
      lexeme: "pi",
    },
    {
      lexeme: "=",
    },
    {
      lexeme: "3.14159",
    },
    {
      lexeme: ";",
    },
    {
      lexeme: "SachGhoot",
    },
    {
      lexeme: "boolVal",
    },
    {
      lexeme: "=",
    },
    {
      lexeme: "sahi",
    },
    {
      lexeme: ";",
    },
    {
      lexeme: "harf",
    },
    {
      lexeme: "symbol",
    },
    {
      lexeme: "=",
    },
    {
      lexeme: "'A'",
    },
    {
      lexeme: ";",
    }
    // ... (continue for all tokens as needed)
  ];
  
  // current token index
  let currentTokenIndex = 0;
  
  const tokenDisplay = document.getElementById("tokenDisplay");
  const backBtn = document.getElementById("backBtn");
  const nextBtn = document.getElementById("nextBtn");
  
  // Generates an array of state strings for a given lexeme
  function simulateDFA(lexeme) {
    let states = [];
    for (let i = 0; i < lexeme.length; i++) {
      states.push(`State${i + 1}(${lexeme[i]})`);
    }
    states.push("Accept");
    return states;
  }
  
  // Render the current token's DFA visualization
  function renderToken() {
    // Clear the display
    tokenDisplay.innerHTML = "";
    
    const token = tokens[currentTokenIndex];
    const lexeme = token.lexeme;
    const dfaStates = simulateDFA(lexeme);
    
    // Create a header showing the token lexeme
    const lexemeHeader = document.createElement("div");
    lexemeHeader.className = "token-lexeme";
    lexemeHeader.textContent = `Token: '${lexeme}'`;
    tokenDisplay.appendChild(lexemeHeader);
    
    // Create container for DFA states
    const dfaContainer = document.createElement("div");
    dfaContainer.className = "dfa-container";
    
    // For each state, create a circle and (if not the last) an arrow after it
    dfaStates.forEach((state, index) => {
      const stateDiv = document.createElement("div");
      stateDiv.className = "state";
      // For state text, remove the "State" text and parentheses if desired, or keep as is.
      stateDiv.textContent = state;
      dfaContainer.appendChild(stateDiv);
      
      if (index < dfaStates.length - 1) {
        const arrowDiv = document.createElement("div");
        arrowDiv.className = "arrow";
        arrowDiv.textContent = "â†’";
        dfaContainer.appendChild(arrowDiv);
      }
    });
    
    tokenDisplay.appendChild(dfaContainer);
    
    // Update button states
    backBtn.disabled = (currentTokenIndex === 0);
    nextBtn.disabled = (currentTokenIndex === tokens.length - 1);
  }
  
  // Next and Back button event listeners
  nextBtn.addEventListener("click", () => {
    if (currentTokenIndex < tokens.length - 1) {
      currentTokenIndex++;
      renderToken();
    }
  });
  
  backBtn.addEventListener("click", () => {
    if (currentTokenIndex > 0) {
      currentTokenIndex--;
      renderToken();
    }
  });
  
  // Render the first token on load
  renderToken();
  